"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ScrollStack.tsx":
/*!************************************!*\
  !*** ./components/ScrollStack.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollStackItem: () => (/* binding */ ScrollStackItem),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lenis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lenis */ \"(app-pages-browser)/./node_modules/lenis/dist/lenis.mjs\");\n\nvar _s = $RefreshSig$();\n\n\nconst ScrollStackItem = (param)=>{\n    let { children, itemClassName = \"\" } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"scroll-stack-card relative w-full h-80 my-8 p-12 rounded-[40px] shadow-[0_0_30px_rgba(0,0,0,0.1)] box-border origin-top will-change-transform \".concat(itemClassName).trim(),\n        style: {\n            backfaceVisibility: 'hidden',\n            transformStyle: 'preserve-3d'\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"A:\\\\BMP-web\\\\components\\\\ScrollStack.tsx\",\n        lineNumber: 5,\n        columnNumber: 3\n    }, undefined);\n};\n_c = ScrollStackItem;\nconst ScrollStack = (param)=>{\n    let { children, className = \"\", itemDistance = 100, itemScale = 0.03, itemStackDistance = 30, stackPosition = \"20%\", scaleEndPosition = \"10%\", baseScale = 0.85, scaleDuration = 0.5, rotationAmount = 0, blurAmount = 0, onStackComplete = undefined } = param;\n    _s();\n    const scrollerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const stackCompletedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const lenisRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const cardsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const lastTransformsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const isUpdatingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const calculateProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollStack.useCallback[calculateProgress]\": (scrollTop, start, end)=>{\n            if (scrollTop < start) return 0;\n            if (scrollTop > end) return 1;\n            return (scrollTop - start) / (end - start);\n        }\n    }[\"ScrollStack.useCallback[calculateProgress]\"], []);\n    const parsePercentage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollStack.useCallback[parsePercentage]\": (value, containerHeight)=>{\n            if (typeof value === 'string' && value.includes('%')) {\n                return parseFloat(value) / 100 * containerHeight;\n            }\n            return parseFloat(value);\n        }\n    }[\"ScrollStack.useCallback[parsePercentage]\"], []);\n    const updateCardTransforms = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollStack.useCallback[updateCardTransforms]\": ()=>{\n            const scroller = scrollerRef.current;\n            if (!scroller || !cardsRef.current.length || isUpdatingRef.current) return;\n            isUpdatingRef.current = true;\n            const scrollTop = scroller.scrollTop;\n            const containerHeight = scroller.clientHeight;\n            const stackPositionPx = parsePercentage(stackPosition, containerHeight);\n            const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\n            const endElement = scroller.querySelector('.scroll-stack-end');\n            const endElementTop = endElement ? endElement.offsetTop : 0;\n            cardsRef.current.forEach({\n                \"ScrollStack.useCallback[updateCardTransforms]\": (card, i)=>{\n                    if (!card) return;\n                    const cardTop = card.offsetTop;\n                    const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\n                    const triggerEnd = cardTop - scaleEndPositionPx;\n                    const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\n                    const pinEnd = endElementTop - containerHeight / 2;\n                    const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\n                    const targetScale = baseScale + i * itemScale;\n                    const scale = 1 - scaleProgress * (1 - targetScale);\n                    const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\n                    let blur = 0;\n                    if (blurAmount) {\n                        let topCardIndex = 0;\n                        for(let j = 0; j < cardsRef.current.length; j++){\n                            const jCardTop = cardsRef.current[j].offsetTop;\n                            const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\n                            if (scrollTop >= jTriggerStart) {\n                                topCardIndex = j;\n                            }\n                        }\n                        if (i < topCardIndex) {\n                            const depthInStack = topCardIndex - i;\n                            blur = Math.max(0, depthInStack * blurAmount);\n                        }\n                    }\n                    let translateY = 0;\n                    const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\n                    if (isPinned) {\n                        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\n                    } else if (scrollTop > pinEnd) {\n                        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\n                    }\n                    const newTransform = {\n                        translateY: Math.round(translateY * 100) / 100,\n                        scale: Math.round(scale * 1000) / 1000,\n                        rotation: Math.round(rotation * 100) / 100,\n                        blur: Math.round(blur * 100) / 100\n                    };\n                    const lastTransform = lastTransformsRef.current.get(i);\n                    const hasChanged = !lastTransform || Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 || Math.abs(lastTransform.scale - newTransform.scale) > 0.001 || Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 || Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\n                    if (hasChanged) {\n                        const transform = \"translate3d(0, \".concat(newTransform.translateY, \"px, 0) scale(\").concat(newTransform.scale, \") rotate(\").concat(newTransform.rotation, \"deg)\");\n                        const filter = newTransform.blur > 0 ? \"blur(\".concat(newTransform.blur, \"px)\") : '';\n                        card.style.transform = transform;\n                        card.style.filter = filter;\n                        lastTransformsRef.current.set(i, newTransform);\n                    }\n                    if (i === cardsRef.current.length - 1) {\n                        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\n                        if (isInView && !stackCompletedRef.current) {\n                            stackCompletedRef.current = true;\n                            onStackComplete === null || onStackComplete === void 0 ? void 0 : onStackComplete();\n                        } else if (!isInView && stackCompletedRef.current) {\n                            stackCompletedRef.current = false;\n                        }\n                    }\n                }\n            }[\"ScrollStack.useCallback[updateCardTransforms]\"]);\n            isUpdatingRef.current = false;\n        }\n    }[\"ScrollStack.useCallback[updateCardTransforms]\"], [\n        itemScale,\n        itemStackDistance,\n        stackPosition,\n        scaleEndPosition,\n        baseScale,\n        rotationAmount,\n        blurAmount,\n        onStackComplete,\n        calculateProgress,\n        parsePercentage\n    ]);\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollStack.useCallback[handleScroll]\": ()=>{\n            updateCardTransforms();\n        }\n    }[\"ScrollStack.useCallback[handleScroll]\"], [\n        updateCardTransforms\n    ]);\n    const setupLenis = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ScrollStack.useCallback[setupLenis]\": ()=>{\n            const scroller = scrollerRef.current;\n            if (!scroller) return;\n            const lenis = new lenis__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                wrapper: scroller,\n                content: scroller.querySelector('.scroll-stack-inner'),\n                duration: 1.2,\n                easing: {\n                    \"ScrollStack.useCallback[setupLenis]\": (t)=>Math.min(1, 1.001 - Math.pow(2, -10 * t))\n                }[\"ScrollStack.useCallback[setupLenis]\"],\n                smoothWheel: true,\n                touchMultiplier: 2,\n                infinite: false,\n                wheelMultiplier: 1,\n                lerp: 0.1,\n                syncTouch: true,\n                syncTouchLerp: 0.075\n            });\n            lenis.on('scroll', handleScroll);\n            const raf = {\n                \"ScrollStack.useCallback[setupLenis].raf\": (time)=>{\n                    lenis.raf(time);\n                    animationFrameRef.current = requestAnimationFrame(raf);\n                }\n            }[\"ScrollStack.useCallback[setupLenis].raf\"];\n            animationFrameRef.current = requestAnimationFrame(raf);\n            lenisRef.current = lenis;\n            return lenis;\n        }\n    }[\"ScrollStack.useCallback[setupLenis]\"], [\n        handleScroll\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)({\n        \"ScrollStack.useLayoutEffect\": ()=>{\n            const scroller = scrollerRef.current;\n            if (!scroller) return;\n            const cards = Array.from(scroller.querySelectorAll(\".scroll-stack-card\"));\n            cardsRef.current = cards;\n            const transformsCache = lastTransformsRef.current;\n            cards.forEach({\n                \"ScrollStack.useLayoutEffect\": (card, i)=>{\n                    if (i < cards.length - 1) {\n                        card.style.marginBottom = \"\".concat(itemDistance, \"px\");\n                    }\n                    card.style.willChange = 'transform, filter';\n                    card.style.transformOrigin = 'top center';\n                    card.style.backfaceVisibility = 'hidden';\n                    card.style.transform = 'translateZ(0)';\n                    card.style.webkitTransform = 'translateZ(0)';\n                    card.style.perspective = '1000px';\n                    card.style.webkitPerspective = '1000px';\n                }\n            }[\"ScrollStack.useLayoutEffect\"]);\n            setupLenis();\n            updateCardTransforms();\n            return ({\n                \"ScrollStack.useLayoutEffect\": ()=>{\n                    if (animationFrameRef.current) {\n                        cancelAnimationFrame(animationFrameRef.current);\n                    }\n                    if (lenisRef.current) {\n                        lenisRef.current.destroy();\n                    }\n                    stackCompletedRef.current = false;\n                    cardsRef.current = [];\n                    transformsCache.clear();\n                    isUpdatingRef.current = false;\n                }\n            })[\"ScrollStack.useLayoutEffect\"];\n        }\n    }[\"ScrollStack.useLayoutEffect\"], [\n        itemDistance,\n        itemScale,\n        itemStackDistance,\n        stackPosition,\n        scaleEndPosition,\n        baseScale,\n        scaleDuration,\n        rotationAmount,\n        blurAmount,\n        onStackComplete,\n        setupLenis,\n        updateCardTransforms\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative w-full h-full overflow-y-auto overflow-x-visible \".concat(className).trim(),\n        ref: scrollerRef,\n        style: {\n            overscrollBehavior: 'contain',\n            WebkitOverflowScrolling: 'touch',\n            scrollBehavior: 'smooth',\n            WebkitTransform: 'translateZ(0)',\n            transform: 'translateZ(0)',\n            willChange: 'scroll-position'\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"scroll-stack-inner pt-[20vh] px-20 pb-[50rem] min-h-screen\",\n            children: [\n                children,\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"scroll-stack-end w-full h-px\"\n                }, void 0, false, {\n                    fileName: \"A:\\\\BMP-web\\\\components\\\\ScrollStack.tsx\",\n                    lineNumber: 268,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"A:\\\\BMP-web\\\\components\\\\ScrollStack.tsx\",\n            lineNumber: 265,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"A:\\\\BMP-web\\\\components\\\\ScrollStack.tsx\",\n        lineNumber: 253,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ScrollStack, \"jQanoUh9Z32xcLUSw++jwwTDx3U=\");\n_c1 = ScrollStack;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ScrollStack);\nvar _c, _c1;\n$RefreshReg$(_c, \"ScrollStackItem\");\n$RefreshReg$(_c1, \"ScrollStack\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvU2Nyb2xsU3RhY2sudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ25DO0FBRW5CLE1BQU1JLGtCQUFrQjtRQUFDLEVBQUVDLFFBQVEsRUFBRUMsZ0JBQWdCLEVBQUUsRUFBRTt5QkFDOUQsOERBQUNDO1FBQ0NDLFdBQVcsaUpBQStKLE9BQWRGLGVBQWdCRyxJQUFJO1FBQ2hMQyxPQUFPO1lBQ0xDLG9CQUFvQjtZQUNwQkMsZ0JBQWdCO1FBQ2xCO2tCQUVDUDs7Ozs7O0VBRUg7S0FWV0Q7QUFZYixNQUFNUyxjQUFjO1FBQUMsRUFDbkJSLFFBQVEsRUFDUkcsWUFBWSxFQUFFLEVBQ2RNLGVBQWUsR0FBRyxFQUNsQkMsWUFBWSxJQUFJLEVBQ2hCQyxvQkFBb0IsRUFBRSxFQUN0QkMsZ0JBQWdCLEtBQUssRUFDckJDLG1CQUFtQixLQUFLLEVBQ3hCQyxZQUFZLElBQUksRUFDaEJDLGdCQUFnQixHQUFHLEVBQ25CQyxpQkFBaUIsQ0FBQyxFQUNsQkMsYUFBYSxDQUFDLEVBQ2RDLGtCQUFrQkMsU0FBUyxFQWM1Qjs7SUFDQyxNQUFNQyxjQUFjeEIsNkNBQU1BLENBQUM7SUFDM0IsTUFBTXlCLG9CQUFvQnpCLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU0wQixvQkFBb0IxQiw2Q0FBTUEsQ0FBQztJQUNqQyxNQUFNMkIsV0FBVzNCLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU00QixXQUFXNUIsNkNBQU1BLENBQUMsRUFBRTtJQUMxQixNQUFNNkIsb0JBQW9CN0IsNkNBQU1BLENBQUMsSUFBSThCO0lBQ3JDLE1BQU1DLGdCQUFnQi9CLDZDQUFNQSxDQUFDO0lBRTdCLE1BQU1nQyxvQkFBb0IvQixrREFBV0E7c0RBQUMsQ0FBQ2dDLFdBQVdDLE9BQU9DO1lBQ3ZELElBQUlGLFlBQVlDLE9BQU8sT0FBTztZQUM5QixJQUFJRCxZQUFZRSxLQUFLLE9BQU87WUFDNUIsT0FBTyxDQUFDRixZQUFZQyxLQUFJLElB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LE9BQU87WUFDTCtHLG9CQUFvQjtZQUNwQkMseUJBQXlCO1lBQ3pCQyxnQkFBZ0I7WUFDaEJDLGlCQUFpQjtZQUNqQjNDLFdBQVc7WUFDWCtCLFlBQVk7UUFDZDtrQkFFQSw0RUFBQ3pHO1lBQUlDLFdBQVU7O2dCQUNaSDs4QkFFRCw4REFBQ0U7b0JBQUlDLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSXZCO0dBaFFNSztNQUFBQTtBQWtRTixpRUFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiQTpcXEJNUC13ZWJcXGNvbXBvbmVudHNcXFNjcm9sbFN0YWNrLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IExlbmlzIGZyb20gXCJsZW5pc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNjcm9sbFN0YWNrSXRlbSA9ICh7IGNoaWxkcmVuLCBpdGVtQ2xhc3NOYW1lID0gXCJcIiB9KSA9PiAoXHJcbiAgPGRpdlxyXG4gICAgY2xhc3NOYW1lPXtgc2Nyb2xsLXN0YWNrLWNhcmQgcmVsYXRpdmUgdy1mdWxsIGgtODAgbXktOCBwLTEyIHJvdW5kZWQtWzQwcHhdIHNoYWRvdy1bMF8wXzMwcHhfcmdiYSgwLDAsMCwwLjEpXSBib3gtYm9yZGVyIG9yaWdpbi10b3Agd2lsbC1jaGFuZ2UtdHJhbnNmb3JtICR7aXRlbUNsYXNzTmFtZX1gLnRyaW0oKX1cclxuICAgIHN0eWxlPXt7XHJcbiAgICAgIGJhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbicsXHJcbiAgICAgIHRyYW5zZm9ybVN0eWxlOiAncHJlc2VydmUtM2QnLFxyXG4gICAgfX1cclxuICA+XHJcbiAgICB7Y2hpbGRyZW59XHJcbiAgPC9kaXY+XHJcbik7XHJcblxyXG5jb25zdCBTY3JvbGxTdGFjayA9ICh7XHJcbiAgY2hpbGRyZW4sXHJcbiAgY2xhc3NOYW1lID0gXCJcIixcclxuICBpdGVtRGlzdGFuY2UgPSAxMDAsXHJcbiAgaXRlbVNjYWxlID0gMC4wMyxcclxuICBpdGVtU3RhY2tEaXN0YW5jZSA9IDMwLFxyXG4gIHN0YWNrUG9zaXRpb24gPSBcIjIwJVwiLFxyXG4gIHNjYWxlRW5kUG9zaXRpb24gPSBcIjEwJVwiLFxyXG4gIGJhc2VTY2FsZSA9IDAuODUsXHJcbiAgc2NhbGVEdXJhdGlvbiA9IDAuNSxcclxuICByb3RhdGlvbkFtb3VudCA9IDAsXHJcbiAgYmx1ckFtb3VudCA9IDAsXHJcbiAgb25TdGFja0NvbXBsZXRlID0gdW5kZWZpbmVkLFxyXG59OiB7XHJcbiAgY2hpbGRyZW46IGFueTtcclxuICBjbGFzc05hbWU/OiBzdHJpbmc7XHJcbiAgaXRlbURpc3RhbmNlPzogbnVtYmVyO1xyXG4gIGl0ZW1TY2FsZT86IG51bWJlcjtcclxuICBpdGVtU3RhY2tEaXN0YW5jZT86IG51bWJlcjtcclxuICBzdGFja1Bvc2l0aW9uPzogc3RyaW5nO1xyXG4gIHNjYWxlRW5kUG9zaXRpb24/OiBzdHJpbmc7XHJcbiAgYmFzZVNjYWxlPzogbnVtYmVyO1xyXG4gIHNjYWxlRHVyYXRpb24/OiBudW1iZXI7XHJcbiAgcm90YXRpb25BbW91bnQ/OiBudW1iZXI7XHJcbiAgYmx1ckFtb3VudD86IG51bWJlcjtcclxuICBvblN0YWNrQ29tcGxldGU/OiAoKSA9PiB2b2lkO1xyXG59KSA9PiB7XHJcbiAgY29uc3Qgc2Nyb2xsZXJSZWYgPSB1c2VSZWYobnVsbCk7XHJcbiAgY29uc3Qgc3RhY2tDb21wbGV0ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gIGNvbnN0IGFuaW1hdGlvbkZyYW1lUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IGxlbmlzUmVmID0gdXNlUmVmKG51bGwpO1xyXG4gIGNvbnN0IGNhcmRzUmVmID0gdXNlUmVmKFtdKTtcclxuICBjb25zdCBsYXN0VHJhbnNmb3Jtc1JlZiA9IHVzZVJlZihuZXcgTWFwKCkpO1xyXG4gIGNvbnN0IGlzVXBkYXRpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG5cclxuICBjb25zdCBjYWxjdWxhdGVQcm9ncmVzcyA9IHVzZUNhbGxiYWNrKChzY3JvbGxUb3AsIHN0YXJ0LCBlbmQpID0+IHtcclxuICAgIGlmIChzY3JvbGxUb3AgPCBzdGFydCkgcmV0dXJuIDA7XHJcbiAgICBpZiAoc2Nyb2xsVG9wID4gZW5kKSByZXR1cm4gMTtcclxuICAgIHJldHVybiAoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KTtcclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IHBhcnNlUGVyY2VudGFnZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZSwgY29udGFpbmVySGVpZ2h0KSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcygnJScpKSB7XHJcbiAgICAgIHJldHVybiAocGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDApICogY29udGFpbmVySGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlQ2FyZFRyYW5zZm9ybXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIXNjcm9sbGVyIHx8ICFjYXJkc1JlZi5jdXJyZW50Lmxlbmd0aCB8fCBpc1VwZGF0aW5nUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICBpc1VwZGF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbGVyLnNjcm9sbFRvcDtcclxuICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IHNjcm9sbGVyLmNsaWVudEhlaWdodDtcclxuICAgIGNvbnN0IHN0YWNrUG9zaXRpb25QeCA9IHBhcnNlUGVyY2VudGFnZShzdGFja1Bvc2l0aW9uLCBjb250YWluZXJIZWlnaHQpO1xyXG4gICAgY29uc3Qgc2NhbGVFbmRQb3NpdGlvblB4ID0gcGFyc2VQZXJjZW50YWdlKHNjYWxlRW5kUG9zaXRpb24sIGNvbnRhaW5lckhlaWdodCk7XHJcbiAgICBjb25zdCBlbmRFbGVtZW50ID0gc2Nyb2xsZXIucXVlcnlTZWxlY3RvcignLnNjcm9sbC1zdGFjay1lbmQnKTtcclxuICAgIGNvbnN0IGVuZEVsZW1lbnRUb3AgPSBlbmRFbGVtZW50ID8gZW5kRWxlbWVudC5vZmZzZXRUb3AgOiAwO1xyXG5cclxuICAgIGNhcmRzUmVmLmN1cnJlbnQuZm9yRWFjaCgoY2FyZCwgaSkgPT4ge1xyXG4gICAgICBpZiAoIWNhcmQpIHJldHVybjtcclxuXHJcbiAgICAgIGNvbnN0IGNhcmRUb3AgPSBjYXJkLm9mZnNldFRvcDtcclxuICAgICAgY29uc3QgdHJpZ2dlclN0YXJ0ID0gY2FyZFRvcCAtIHN0YWNrUG9zaXRpb25QeCAtIChpdGVtU3RhY2tEaXN0YW5jZSAqIGkpO1xyXG4gICAgICBjb25zdCB0cmlnZ2VyRW5kID0gY2FyZFRvcCAtIHNjYWxlRW5kUG9zaXRpb25QeDtcclxuICAgICAgY29uc3QgcGluU3RhcnQgPSBjYXJkVG9wIC0gc3RhY2tQb3NpdGlvblB4IC0gKGl0ZW1TdGFja0Rpc3RhbmNlICogaSk7XHJcbiAgICAgIGNvbnN0IHBpbkVuZCA9IGVuZEVsZW1lbnRUb3AgLSBjb250YWluZXJIZWlnaHQgLyAyO1xyXG5cclxuICAgICAgY29uc3Qgc2NhbGVQcm9ncmVzcyA9IGNhbGN1bGF0ZVByb2dyZXNzKHNjcm9sbFRvcCwgdHJpZ2dlclN0YXJ0LCB0cmlnZ2VyRW5kKTtcclxuICAgICAgY29uc3QgdGFyZ2V0U2NhbGUgPSBiYXNlU2NhbGUgKyAoaSAqIGl0ZW1TY2FsZSk7XHJcbiAgICAgIGNvbnN0IHNjYWxlID0gMSAtIHNjYWxlUHJvZ3Jlc3MgKiAoMSAtIHRhcmdldFNjYWxlKTtcclxuICAgICAgY29uc3Qgcm90YXRpb24gPSByb3RhdGlvbkFtb3VudCA/IGkgKiByb3RhdGlvbkFtb3VudCAqIHNjYWxlUHJvZ3Jlc3MgOiAwO1xyXG5cclxuICAgICAgbGV0IGJsdXIgPSAwO1xyXG4gICAgICBpZiAoYmx1ckFtb3VudCkge1xyXG4gICAgICAgIGxldCB0b3BDYXJkSW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2FyZHNSZWYuY3VycmVudC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgY29uc3QgakNhcmRUb3AgPSBjYXJkc1JlZi5jdXJyZW50W2pdLm9mZnNldFRvcDtcclxuICAgICAgICAgIGNvbnN0IGpUcmlnZ2VyU3RhcnQgPSBqQ2FyZFRvcCAtIHN0YWNrUG9zaXRpb25QeCAtIChpdGVtU3RhY2tEaXN0YW5jZSAqIGopO1xyXG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSBqVHJpZ2dlclN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRvcENhcmRJbmRleCA9IGo7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpIDwgdG9wQ2FyZEluZGV4KSB7XHJcbiAgICAgICAgICBjb25zdCBkZXB0aEluU3RhY2sgPSB0b3BDYXJkSW5kZXggLSBpO1xyXG4gICAgICAgICAgYmx1ciA9IE1hdGgubWF4KDAsIGRlcHRoSW5TdGFjayAqIGJsdXJBbW91bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHRyYW5zbGF0ZVkgPSAwO1xyXG4gICAgICBjb25zdCBpc1Bpbm5lZCA9IHNjcm9sbFRvcCA+PSBwaW5TdGFydCAmJiBzY3JvbGxUb3AgPD0gcGluRW5kO1xyXG4gICAgICBcclxuICAgICAgaWYgKGlzUGlubmVkKSB7XHJcbiAgICAgICAgdHJhbnNsYXRlWSA9IHNjcm9sbFRvcCAtIGNhcmRUb3AgKyBzdGFja1Bvc2l0aW9uUHggKyAoaXRlbVN0YWNrRGlzdGFuY2UgKiBpKTtcclxuICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPiBwaW5FbmQpIHtcclxuICAgICAgICB0cmFuc2xhdGVZID0gcGluRW5kIC0gY2FyZFRvcCArIHN0YWNrUG9zaXRpb25QeCArIChpdGVtU3RhY2tEaXN0YW5jZSAqIGkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBuZXdUcmFuc2Zvcm0gPSB7XHJcbiAgICAgICAgdHJhbnNsYXRlWTogTWF0aC5yb3VuZCh0cmFuc2xhdGVZICogMTAwKSAvIDEwMCxcclxuICAgICAgICBzY2FsZTogTWF0aC5yb3VuZChzY2FsZSAqIDEwMDApIC8gMTAwMCxcclxuICAgICAgICByb3RhdGlvbjogTWF0aC5yb3VuZChyb3RhdGlvbiAqIDEwMCkgLyAxMDAsXHJcbiAgICAgICAgYmx1cjogTWF0aC5yb3VuZChibHVyICogMTAwKSAvIDEwMFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgY29uc3QgbGFzdFRyYW5zZm9ybSA9IGxhc3RUcmFuc2Zvcm1zUmVmLmN1cnJlbnQuZ2V0KGkpO1xyXG4gICAgICBjb25zdCBoYXNDaGFuZ2VkID0gIWxhc3RUcmFuc2Zvcm0gfHwgXHJcbiAgICAgICAgTWF0aC5hYnMobGFzdFRyYW5zZm9ybS50cmFuc2xhdGVZIC0gbmV3VHJhbnNmb3JtLnRyYW5zbGF0ZVkpID4gMC4xIHx8XHJcbiAgICAgICAgTWF0aC5hYnMobGFzdFRyYW5zZm9ybS5zY2FsZSAtIG5ld1RyYW5zZm9ybS5zY2FsZSkgPiAwLjAwMSB8fFxyXG4gICAgICAgIE1hdGguYWJzKGxhc3RUcmFuc2Zvcm0ucm90YXRpb24gLSBuZXdUcmFuc2Zvcm0ucm90YXRpb24pID4gMC4xIHx8XHJcbiAgICAgICAgTWF0aC5hYnMobGFzdFRyYW5zZm9ybS5ibHVyIC0gbmV3VHJhbnNmb3JtLmJsdXIpID4gMC4xO1xyXG5cclxuICAgICAgaWYgKGhhc0NoYW5nZWQpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgJHtuZXdUcmFuc2Zvcm0udHJhbnNsYXRlWX1weCwgMCkgc2NhbGUoJHtuZXdUcmFuc2Zvcm0uc2NhbGV9KSByb3RhdGUoJHtuZXdUcmFuc2Zvcm0ucm90YXRpb259ZGVnKWA7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gbmV3VHJhbnNmb3JtLmJsdXIgPiAwID8gYGJsdXIoJHtuZXdUcmFuc2Zvcm0uYmx1cn1weClgIDogJyc7XHJcblxyXG4gICAgICAgIGNhcmQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIGNhcmQuc3R5bGUuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxhc3RUcmFuc2Zvcm1zUmVmLmN1cnJlbnQuc2V0KGksIG5ld1RyYW5zZm9ybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpID09PSBjYXJkc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICBjb25zdCBpc0luVmlldyA9IHNjcm9sbFRvcCA+PSBwaW5TdGFydCAmJiBzY3JvbGxUb3AgPD0gcGluRW5kO1xyXG4gICAgICAgIGlmIChpc0luVmlldyAmJiAhc3RhY2tDb21wbGV0ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgc3RhY2tDb21wbGV0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICBvblN0YWNrQ29tcGxldGU/LigpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzSW5WaWV3ICYmIHN0YWNrQ29tcGxldGVkUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgIHN0YWNrQ29tcGxldGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlzVXBkYXRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gIH0sIFtcclxuICAgIGl0ZW1TY2FsZSxcclxuICAgIGl0ZW1TdGFja0Rpc3RhbmNlLFxyXG4gICAgc3RhY2tQb3NpdGlvbixcclxuICAgIHNjYWxlRW5kUG9zaXRpb24sXHJcbiAgICBiYXNlU2NhbGUsXHJcbiAgICByb3RhdGlvbkFtb3VudCxcclxuICAgIGJsdXJBbW91bnQsXHJcbiAgICBvblN0YWNrQ29tcGxldGUsXHJcbiAgICBjYWxjdWxhdGVQcm9ncmVzcyxcclxuICAgIHBhcnNlUGVyY2VudGFnZSxcclxuICBdKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgdXBkYXRlQ2FyZFRyYW5zZm9ybXMoKTtcclxuICB9LCBbdXBkYXRlQ2FyZFRyYW5zZm9ybXNdKTtcclxuXHJcbiAgY29uc3Qgc2V0dXBMZW5pcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IHNjcm9sbGVyID0gc2Nyb2xsZXJSZWYuY3VycmVudDtcclxuICAgIGlmICghc2Nyb2xsZXIpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBsZW5pcyA9IG5ldyBMZW5pcyh7XHJcbiAgICAgIHdyYXBwZXI6IHNjcm9sbGVyLFxyXG4gICAgICBjb250ZW50OiBzY3JvbGxlci5xdWVyeVNlbGVjdG9yKCcuc2Nyb2xsLXN0YWNrLWlubmVyJyksXHJcbiAgICAgIGR1cmF0aW9uOiAxLjIsXHJcbiAgICAgIGVhc2luZzogKHQpID0+IE1hdGgubWluKDEsIDEuMDAxIC0gTWF0aC5wb3coMiwgLTEwICogdCkpLFxyXG4gICAgICBzbW9vdGhXaGVlbDogdHJ1ZSxcclxuICAgICAgdG91Y2hNdWx0aXBsaWVyOiAyLFxyXG4gICAgICBpbmZpbml0ZTogZmFsc2UsXHJcbiAgICAgIHdoZWVsTXVsdGlwbGllcjogMSxcclxuICAgICAgbGVycDogMC4xLFxyXG4gICAgICBzeW5jVG91Y2g6IHRydWUsXHJcbiAgICAgIHN5bmNUb3VjaExlcnA6IDAuMDc1LFxyXG4gICAgfSk7XHJcblxyXG4gICAgbGVuaXMub24oJ3Njcm9sbCcsIGhhbmRsZVNjcm9sbCk7XHJcblxyXG4gICAgY29uc3QgcmFmID0gKHRpbWUpID0+IHtcclxuICAgICAgbGVuaXMucmFmKHRpbWUpO1xyXG4gICAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZik7XHJcbiAgICB9O1xyXG4gICAgYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWYpO1xyXG5cclxuICAgIGxlbmlzUmVmLmN1cnJlbnQgPSBsZW5pcztcclxuICAgIHJldHVybiBsZW5pcztcclxuICB9LCBbaGFuZGxlU2Nyb2xsXSk7XHJcblxyXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIXNjcm9sbGVyKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgY2FyZHMgPSBBcnJheS5mcm9tKHNjcm9sbGVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuc2Nyb2xsLXN0YWNrLWNhcmRcIikpO1xyXG4gICAgY2FyZHNSZWYuY3VycmVudCA9IGNhcmRzO1xyXG4gICAgY29uc3QgdHJhbnNmb3Jtc0NhY2hlID0gbGFzdFRyYW5zZm9ybXNSZWYuY3VycmVudDtcclxuXHJcbiAgICBjYXJkcy5mb3JFYWNoKChjYXJkLCBpKSA9PiB7XHJcbiAgICAgIGlmIChpIDwgY2FyZHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgIGNhcmQuc3R5bGUubWFyZ2luQm90dG9tID0gYCR7aXRlbURpc3RhbmNlfXB4YDtcclxuICAgICAgfVxyXG4gICAgICBjYXJkLnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtLCBmaWx0ZXInO1xyXG4gICAgICBjYXJkLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICd0b3AgY2VudGVyJztcclxuICAgICAgY2FyZC5zdHlsZS5iYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgICAgY2FyZC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWigwKSc7XHJcbiAgICAgIGNhcmQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xyXG4gICAgICBjYXJkLnN0eWxlLnBlcnNwZWN0aXZlID0gJzEwMDBweCc7XHJcbiAgICAgIGNhcmQuc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSAnMTAwMHB4JztcclxuICAgIH0pO1xyXG5cclxuICAgIHNldHVwTGVuaXMoKTtcclxuXHJcbiAgICB1cGRhdGVDYXJkVHJhbnNmb3JtcygpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGxlbmlzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBsZW5pc1JlZi5jdXJyZW50LmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgICBzdGFja0NvbXBsZXRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgIGNhcmRzUmVmLmN1cnJlbnQgPSBbXTtcclxuICAgICAgdHJhbnNmb3Jtc0NhY2hlLmNsZWFyKCk7XHJcbiAgICAgIGlzVXBkYXRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICB9LCBbXHJcbiAgICBpdGVtRGlzdGFuY2UsXHJcbiAgICBpdGVtU2NhbGUsXHJcbiAgICBpdGVtU3RhY2tEaXN0YW5jZSxcclxuICAgIHN0YWNrUG9zaXRpb24sXHJcbiAgICBzY2FsZUVuZFBvc2l0aW9uLFxyXG4gICAgYmFzZVNjYWxlLFxyXG4gICAgc2NhbGVEdXJhdGlvbixcclxuICAgIHJvdGF0aW9uQW1vdW50LFxyXG4gICAgYmx1ckFtb3VudCxcclxuICAgIG9uU3RhY2tDb21wbGV0ZSxcclxuICAgIHNldHVwTGVuaXMsXHJcbiAgICB1cGRhdGVDYXJkVHJhbnNmb3JtcyxcclxuICBdKTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXZcclxuICAgICAgY2xhc3NOYW1lPXtgcmVsYXRpdmUgdy1mdWxsIGgtZnVsbCBvdmVyZmxvdy15LWF1dG8gb3ZlcmZsb3cteC12aXNpYmxlICR7Y2xhc3NOYW1lfWAudHJpbSgpfVxyXG4gICAgICByZWY9e3Njcm9sbGVyUmVmfVxyXG4gICAgICBzdHlsZT17eyBcclxuICAgICAgICBvdmVyc2Nyb2xsQmVoYXZpb3I6ICdjb250YWluJyxcclxuICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJyxcclxuICAgICAgICBzY3JvbGxCZWhhdmlvcjogJ3Ntb290aCcsXHJcbiAgICAgICAgV2Via2l0VHJhbnNmb3JtOiAndHJhbnNsYXRlWigwKScsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWigwKScsXHJcbiAgICAgICAgd2lsbENoYW5nZTogJ3Njcm9sbC1wb3NpdGlvbidcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzY3JvbGwtc3RhY2staW5uZXIgcHQtWzIwdmhdIHB4LTIwIHBiLVs1MHJlbV0gbWluLWgtc2NyZWVuXCI+XHJcbiAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIHsvKiBTcGFjZXIgc28gdGhlIGxhc3QgcGluIGNhbiByZWxlYXNlIGNsZWFubHkgKi99XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzY3JvbGwtc3RhY2stZW5kIHctZnVsbCBoLXB4XCIgLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsU3RhY2s7ICJdLCJuYW1lcyI6WyJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsIkxlbmlzIiwiU2Nyb2xsU3RhY2tJdGVtIiwiY2hpbGRyZW4iLCJpdGVtQ2xhc3NOYW1lIiwiZGl2IiwiY2xhc3NOYW1lIiwidHJpbSIsInN0eWxlIiwiYmFja2ZhY2VWaXNpYmlsaXR5IiwidHJhbnNmb3JtU3R5bGUiLCJTY3JvbGxTdGFjayIsIml0ZW1EaXN0YW5jZSIsIml0ZW1TY2FsZSIsIml0ZW1TdGFja0Rpc3RhbmNlIiwic3RhY2tQb3NpdGlvbiIsInNjYWxlRW5kUG9zaXRpb24iLCJiYXNlU2NhbGUiLCJzY2FsZUR1cmF0aW9uIiwicm90YXRpb25BbW91bnQiLCJibHVyQW1vdW50Iiwib25TdGFja0NvbXBsZXRlIiwidW5kZWZpbmVkIiwic2Nyb2xsZXJSZWYiLCJzdGFja0NvbXBsZXRlZFJlZiIsImFuaW1hdGlvbkZyYW1lUmVmIiwibGVuaXNSZWYiLCJjYXJkc1JlZiIsImxhc3RUcmFuc2Zvcm1zUmVmIiwiTWFwIiwiaXNVcGRhdGluZ1JlZiIsImNhbGN1bGF0ZVByb2dyZXNzIiwic2Nyb2xsVG9wIiwic3RhcnQiLCJlbmQiLCJwYXJzZVBlcmNlbnRhZ2UiLCJ2YWx1ZSIsImNvbnRhaW5lckhlaWdodCIsImluY2x1ZGVzIiwicGFyc2VGbG9hdCIsInVwZGF0ZUNhcmRUcmFuc2Zvcm1zIiwic2Nyb2xsZXIiLCJjdXJyZW50IiwibGVuZ3RoIiwiY2xpZW50SGVpZ2h0Iiwic3RhY2tQb3NpdGlvblB4Iiwic2NhbGVFbmRQb3NpdGlvblB4IiwiZW5kRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJlbmRFbGVtZW50VG9wIiwib2Zmc2V0VG9wIiwiZm9yRWFjaCIsImNhcmQiLCJpIiwiY2FyZFRvcCIsInRyaWdnZXJTdGFydCIsInRyaWdnZXJFbmQiLCJwaW5TdGFydCIsInBpbkVuZCIsInNjYWxlUHJvZ3Jlc3MiLCJ0YXJnZXRTY2FsZSIsInNjYWxlIiwicm90YXRpb24iLCJibHVyIiwidG9wQ2FyZEluZGV4IiwiaiIsImpDYXJkVG9wIiwialRyaWdnZXJTdGFydCIsImRlcHRoSW5TdGFjayIsIk1hdGgiLCJtYXgiLCJ0cmFuc2xhdGVZIiwiaXNQaW5uZWQiLCJuZXdUcmFuc2Zvcm0iLCJyb3VuZCIsImxhc3RUcmFuc2Zvcm0iLCJnZXQiLCJoYXNDaGFuZ2VkIiwiYWJzIiwidHJhbnNmb3JtIiwiZmlsdGVyIiwic2V0IiwiaXNJblZpZXciLCJoYW5kbGVTY3JvbGwiLCJzZXR1cExlbmlzIiwibGVuaXMiLCJ3cmFwcGVyIiwiY29udGVudCIsImR1cmF0aW9uIiwiZWFzaW5nIiwidCIsIm1pbiIsInBvdyIsInNtb290aFdoZWVsIiwidG91Y2hNdWx0aXBsaWVyIiwiaW5maW5pdGUiLCJ3aGVlbE11bHRpcGxpZXIiLCJsZXJwIiwic3luY1RvdWNoIiwic3luY1RvdWNoTGVycCIsIm9uIiwicmFmIiwidGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhcmRzIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsInRyYW5zZm9ybXNDYWNoZSIsIm1hcmdpbkJvdHRvbSIsIndpbGxDaGFuZ2UiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsIndlYmtpdFBlcnNwZWN0aXZlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZXN0cm95IiwiY2xlYXIiLCJyZWYiLCJvdmVyc2Nyb2xsQmVoYXZpb3IiLCJXZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsInNjcm9sbEJlaGF2aW9yIiwiV2Via2l0VHJhbnNmb3JtIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ScrollStack.tsx\n"));

/***/ })

});